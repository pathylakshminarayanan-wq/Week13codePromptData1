import pandas as pd
import traceback
import os
from promptflow import tool


@tool
def execute_python_code(code: str):
    """
    Executes LLM-generated Python code against the Supply Chain dataset.

    :param code: The Python code string generated by the LLM.
    :return: A string representation of the 'result' variable or an error message.
    """

    file_path = "data/DataCoSupplyChainDataset.csv"

    # 1. Validate input
    if not code:
        return "Error: No code provided by the LLM."

    # 2. Strip Markdown formatting if present
    if "```python" in code:
        code = code.split("```python")[1].split("```")[0].strip()
    elif "```" in code:
        code = code.split("```")[1].split("```")[0].strip()

    try:
        # 3. Load the dataset
        # ISO-8859-1 encoding is standard for this dataset
        df = pd.read_csv(file_path, encoding="ISO-8859-1")

        # 4. Standardize column names
        df.columns = [
            col.replace(" ", "_")
               .replace("(", "")
               .replace(")", "")
               .replace("/", "_")
               .replace("-", "_")
            for col in df.columns
        ]

        # 5. Prepare execution environment
        local_vars = {
            "df": df,
            "pd": pd,
            "result": None
        }

        # 6. Execute LLM-generated code
        exec(code, {"__builtins__": __builtins__}, local_vars)

        # 7. Fetch execution result
        execution_output = local_vars.get("result")

        if execution_output is None:
            return (
                "Success: Code executed, but no 'result' was assigned. "
                "Ensure your prompt tells the model to assign the answer to "
                "the 'result' variable."
            )

        # 8. Format output for downstream Prompt Flow nodes
        if isinstance(execution_output, (pd.DataFrame, pd.Series)):
            try:
                return execution_output.to_markdown()
            except ImportError:
                return execution_output.to_string()

        return str(execution_output)

    except Exception as e:
        error_type = type(e).__name__
        return (
            f"Error during execution [{error_type}]: {str(e)}\n\n"
            f"Traceback:\n{traceback.format_exc()}"
        )
         
    # --- HARD SANITIZATION (NO MERCY) ---
    lines = code.splitlines()
    cleaned_lines = []

    for line in lines:
        line = line.rstrip()
        if line.endswith("."):
            line = line[:-1]   # remove dangling dot
        cleaned_lines.append(line)

    code = "\n".join(cleaned_lines)
    # -----------------------------------

    local_vars = {"df": df}

    try:
        exec(code, {"__builtins__": __builtins__}, local_vars)
        return local_vars.get("result")

    except Exception as e:
        return {
            "status": "failed",
            "error_type": type(e).__name__,
            "error_message": str(e),
            "code_used": code
        }
